(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{188:function(e,t,a){"use strict";a.r(t);var i=a(0),r=Object(i.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[e._m(0),e._v(" "),e._m(1),e._v(" "),a("p",[a("em",[a("strong",[e._v("PIP Editor Note:")]),e._v(" This PIP was created retrospectively based of the "),a("a",{attrs:{href:"https://github.com/PascalCoin/PascalCoin/blob/master/PascalCoinWhitePaperV2.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Whitepaper V2"),a("OutboundLink")],1),e._v(" on 2017-08-15.")])]),e._v(" "),e._m(2),e._v(" "),e._m(3),a("p",[e._v("This PIP proposes a fundamental change to the SafeBox allowing PascalCoin to achieve practically infinite running-time on finite and constant storage. This PIP proposes nodes discard blocks after the height of 100 whilst retaining the (SPV) cryptographic security of the full blockchain. This way, PascalCoin need only store the flow of transactions rather than the history -- a fundamental breakthrough in Blockchain technology.")]),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),a("p",[e._v("Full technical specification can be found in "),a("a",{attrs:{href:"https://github.com/PascalCoin/PascalCoin/blob/master/PascalCoinWhitePaperV2.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Whitepaper V2"),a("OutboundLink")],1),e._v(".")]),e._v(" "),e._m(9),e._v(" "),a("p",[e._v('PascalCoin V1 was released with the promise of "deletable blockchain" yet the original implementation only delivered "prunable blockchain". With this PIP, PascalCoin now delivers on it\'s original promise.')]),e._v(" "),e._m(10),e._v(" "),a("p",[e._v("Changes are not backwards compatible and will require a hard-fork.")]),e._v(" "),e._m(11),e._v(" "),a("p",[e._v("None provided. This PIP has been implemented in V2.")]),e._v(" "),e._m(12),e._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"https://github.com/PascalCoin/PascalCoin/blob/master/PascalCoinWhitePaperV2.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("PascalCoin White Paper V2"),a("OutboundLink")],1)])])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"pip-0003-infinite-scaling-via-deletable-blockchain"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pip-0003-infinite-scaling-via-deletable-blockchain","aria-hidden":"true"}},[this._v("#")]),this._v(" PIP-0003: Infinite Scaling via Deletable Blockchain")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[this._v("  PIP: 3\n  Title: Infinite Scaling via Deletable Blockchain\n  Type: Protocol \n  Impact: Hard-Fork\n  Author: Herman Schoenfeld "),t("i",[this._v("<herman@sphere10.com>")]),this._v("\n  Comments-URI: N/A\n  Status: Active\n  Created: 2017-03-01\n")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"summary"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#summary","aria-hidden":"true"}},[this._v("#")]),this._v(" Summary")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-php extra-class"},[t("pre",{pre:!0,attrs:{class:"language-php"}},[t("code",[t("span",{pre:!0,attrs:{class:"token php language-php"}},[t("span",{pre:!0,attrs:{class:"token delimiter important"}},[this._v("<?php")]),this._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[this._v("echo")]),this._v(" "),t("span",{pre:!0,attrs:{class:"token variable"}},[this._v("$hallo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[this._v(";")]),this._v("\n")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"motivation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#motivation","aria-hidden":"true"}},[this._v("#")]),this._v(" Motivation")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("In PascalCoin V1, new nodes are required to syncronize from the genesis block in order to determine the most-work-chain. Without the full block history, nodes can never independently determine the most-work-chain. Over time, this will lead to centralisation as the storage requirements for nodes approach that of data-centers. This problem exists for all other cryptocurrencies (at the time of this writing) as over a protracted period of time, these cryptocurrencies will become impractically large for ordinary computers to store resulting in their eventual death. With this PIP, "),t("strong",[this._v("the PascalCoin network can run for centuries at arbitrarily-high throughput and yet still require less storage than Bitcoin does today!")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"specification"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#specification","aria-hidden":"true"}},[this._v("#")]),this._v(" Specification")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[e._v("The SafeBox will retain the block header in every Account Segment sub-structure.")]),e._v(" "),a("li",[e._v("New blocks will be appended to the top of the chain and blocks with height greater than 100 will be deleted from the bottom.")]),e._v(" "),a("li",[e._v("On every 100th block, a copy of the SafeBox will be made and referred to as a 'Checkpoint'.")]),e._v(" "),a("li",[e._v("When a new nodes syncronize, they downloads the latest known Checkpoint and then the blocks minted after.")]),e._v(" "),a("li",[e._v("Checkpoints are fully and independently verified by nodes as follows:\n"),a("ol",[a("li",[e._v("All the Block Headers are hashed again and that they all link transitively via chain is checked.")]),e._v(" "),a("li",[e._v("Let TotalWork = sum of Compact Target for every block header")]),e._v(" "),a("li",[e._v("Verify that the TotalWork of the SafeBox is the largest known in the network.")]),e._v(" "),a("li",[e._v("If the SafeBox is structurally invalid or there exists another SafeBox with higher TotalWork, then it is discarded and the advertisting nodes blacklisted.")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("Note")]),this._v(": A sybil-attack using a forged SafeBox is an unsufficient condition to overwrite the honest SafeBox since nodes will always choose the SafeBox with the highest total work. In order for a forged SafeBox to overwrite the hoenst network's SafeBox, the attacker must re-mine all the past blocks (and then some) faster than the honest SafeBox continues to grow --virtually a physical impossibility.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"rationale"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rationale","aria-hidden":"true"}},[this._v("#")]),this._v(" Rationale")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"backwards-compatibility"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility","aria-hidden":"true"}},[this._v("#")]),this._v(" Backwards Compatibility")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"reference-implementation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reference-implementation","aria-hidden":"true"}},[this._v("#")]),this._v(" Reference Implementation")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"links"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#links","aria-hidden":"true"}},[this._v("#")]),this._v(" Links")])}],!1,null,null,null);t.default=r.exports}}]);